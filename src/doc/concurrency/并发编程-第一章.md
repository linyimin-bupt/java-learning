### 第一章 并发编程中常见的问题

#### 相关概念

- 时间片： CPU分配给各个线程的时间
- 上下文切换： 保存当前任务状态，加载下一个任务状态

#### 常见问题

- 上下文切换问题
- 死锁问题
- 受限于硬件和软件的资源问题
  - 硬件
    - 网络的带宽上传和下载速度
    - 硬盘的读写速度
    - CPU的处理速度
  - 软件
    - 数据库的连接数
    - socket的连接数

#### 解决方法


**避免死锁的常见方法：**

- 避免在一个线程中同时获取多个锁；
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
- 尝试使用锁时，使用lock.tryLock(timeout)代替使用内部锁机制
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。



**解决资源限制的方法：**

- 硬件限制
  - 使用集群并行执行程序
    - 不同的机器处理不同的数据
- 软件限制
  - 使用资源池将资源进行复用
- 并发编程
  - 根据不同的资源限制调整程序的并发度


**减少上下文切换的次数的方法：**

- 无锁并发编程
  - 数据ID按照Hash算法取模分段，不同的线程处理不同段的数据
- CAS算法
  - 使用java的Atomic包


- 使用最少线程
- 使用协程
  - 下单线程里实现多任务的调度，并在单线程里维持多个任务间的切换



#### 相关知识

**锁机制**

- 互斥性： 在同一时间只允许一个线程持有某个对象锁(操作的原子性)
- 可见性： 在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的。

**synchronized关键字**

- 对象锁
  - synchronized(this|object){}
  - 修饰非静态方法
- 类锁
  - synchronized(类.class){}
  - 修饰静态方法

**对象锁：**

- 一个线程在访问对象的同步代码块，另一个访问对象的同步代码块的线程会被阻塞
- synchronized(this|object) {} 代码块 {} 之外的代码依然是异步的
- 类中 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法获取的锁是同一个锁，即该类的对象的对象锁。同一个对象锁会相互干扰
- 两个线程访问不同对象的 synchronized(this|object) {} 代码块和 synchronized 修饰非静态方法是异步的，同一个类的不同对象的对象锁互不干扰。

**类锁：**

- 类中 synchronized(类.class) {} 代码块和 synchronized 修饰静态方法获取的锁是类锁。对于同一个类的不同对象的类锁是同一个。是同步的。

对象锁和类锁的关系：**对象锁和类锁是独立的，互不干扰。**

synchronized关键字其他注意事项：

- synchronized关键字不能继承；
  - 对于父类中synchronized关键字修饰的方法，子类在覆盖改方法时，默认情况下不是同步的，必须显示使用synchronized关键字修饰才行。
- 在定义接口方法时，不能使用synchronized关键字修饰；
- 构造方法上不能使用synchronized关键字修饰，但是可以使用synchronized关键字进行同步操作。










