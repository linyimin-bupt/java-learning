### 第五章 Java中的锁

#### Lock接口

功能与synchronized关键字类似，但是Lock具有自己独特的性质：

- 尝试非阻塞地获取锁
- 能被中断地获取锁
- 超时获取锁

Lock接口定义了锁获取和释放的基本操作



#### 队列同步器(AbstractQueuedSychronizer)

用途： 用来构建锁或者其他同步组件的基础框架。

使用方式：通过继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。在抽象方法的实现过程中，使用同步器提供的(getState(),setState(int newState), compareAndSetState(int expect, int update))来进行操作，这三个状态管理方法能保证状态的改变是安全的。支持独占式和共享式地获取同步状态。



锁与同步器的关系：

- 锁是面向使用者的，定义使用者与锁交互的接口(如可以允许两个线程并行访问)，并隐藏了实现细节;
- 同步器是锁的实现者的，简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。

同步器提供的模板方法：

- 独占式获取与释放同步状态
- 共享式获取与释放同步状态
- 查询同步队列中的等待线程情况



独占锁： 在某一时刻，只能有一个线程获取到锁，而其他获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能获取锁。

#### 队列同步器的实现分析

- 同步队列
  - 使用一个内部同步队列(FIFO双向同步队列)完成同步状态的管理，当前线程获取同步状态失败时,同步器会将当前线程及等待信息构成一个节点(Node)并将其加入同步队列，同时阻塞当前线程，当同步状态释放时，同步器将队列中首节点对应的线程唤醒，使其再次尝试获取同步状态。
  - Node节点保存获取同步状态失败的线程引用、等待状态以及前驱结点和后继节点。
  - 由于可能会有多个线程同时尝试获取同步状态，而只有一个线程能获取同步状态，其余的线程会被构造成节点加入到同步队列中，所以**入队的过程需要保证线程安全**
  - 同步队列中的首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，会唤醒后继节点，而后继节点会在获取同步状态时将自己设置成首节点。而只有一个线程能成功获取到同步状态，所以设置首节点的方法本身就是线程安全的，不需要使用CAS来保证
- 独占式同步状态获取与释放
- 共享式同步状态获取与释放
- 超时获取同步状态
- 模板方法




补充知识：

公平锁：最先进入同步队列的线程先获得锁

非公平锁：锁释放之后，会唤醒所有的线程，让他们再次尝试获取锁，可能会导致后来的线程鲜活的锁







注：volatile修饰的变量在多线程中的单操作中可以保证写后读的可见性，但是并不能保证线程安全。例如在以来原始值时，线程是不安全的。

在AbstractQueuedSychronizer中compareAndSetState(int expect, int update)方法可以划分为一下操作：

1. 比较expect和state变量的当前值，如果相同，继续2，如果不同，返回false，方法结束
2. 将state当前值设为update，并发回true，方法结束

这两个操作，如果是多线程并发调用，是会有线程安全问题的。这里的 cas 方法利用了 cpu 的 cas 指令，这个指令是原子操作。可以避免并发问题。

重入锁

概念:支持重入的锁,支持一个线程对资源的重复加锁,在调用lock()方法时,已经获取到锁的线程,能够再次调用lock()方法获取锁而不被阻塞.

基于AbstractQueuedSychronizer的公平锁和非公平锁的实现

基于AQS的锁原理:

- 有一个state变量，初始值为0，假设当前线程为A,每当A获取一次锁，state++. 释放一次，state--.锁会记录当前持有的线程。
- 当A线程拥有锁的时候，state>0. B线程尝试获取锁的时候会对这个state有一个CAS(0,1)的操作，尝试几次失败后就挂起线程，进入一个等待队列。
- 如果A线程恰好释放，--status==0, A线程会去唤醒等待队列中第一个线程，即刚刚进入等待队列的B线程，B线程被唤醒之后回去检查这个status的值，尝试CAS(0,1),而如果这时恰好C线程也尝试去争抢这把锁.

公平锁的实现:

- 在竞争时,先让B线程获取同步状态

非公平锁的实现:

- 同时竞争,可以是C线程先获取同步状态



非公平性锁:

- 可能造成饥饿
- 线程切换次数少

公平性锁:

- 保证锁的获取按照FIFO原则
- 大量的线程切换

读写锁

读写锁的自定义同步器需要在同步状态(一个整型变量)上维护多个读线程和一个写线程的状态,使得该状态的设计成为读写锁实现的关键。



一个整型变量维护多种状态: 按位切割使用该变量

读写锁通过位运算迅速确定读和写各自的主状态

- 写状态: S&0x0000FFFF
- 读状态: S>>>16(无符号补0右移u

推论:

S不等于0时,当写状态(S&0x0000FFFF)等于0时,则读状态(S>>>16)大于0,即读锁已被获取。



锁降级:

写锁降级成为读锁,步骤: 获取写锁-->获取读锁-->释放写锁(在同一个线程中,可以同时获得写锁和读锁)

LockSupport:阻塞或唤醒一个线程





Condition

等待/通知的实现模式:

1. Object(需要synchronized关键字配合)
   - wait()
   - notify()
2. Lock(需要Condition接口配合)
   - await()
   - signal()

Condition的实现主要包括:等待队列,等待和通知,每个Condition对象都包含着一个队列及(等待队列)



Condition在等待时,当前线程会进入等待队列并释放已经获取到的锁.从队列的角度上看,相当于同步队列的首节点(获取到锁的节点)移动到Condition对应的等待队列中.

调用Condition的signal()方法,将会唤醒在等待队列中等待时间最长的节点(首节点),在唤醒节点之前,会将节点移到同步队列中。









