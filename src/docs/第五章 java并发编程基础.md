### 第五章 Java中的锁

#### Lock接口

功能与synchronized关键字类似，但是Lock具有自己独特的性质：

- 尝试非阻塞地获取锁
- 能被中断地获取锁
- 超时获取锁

Lock接口定义了锁获取和释放的基本操作



#### 队列同步器(AbstractQueuedSychronizer)

用途： 用来构建锁或者其他同步组件的基础框架。

使用方式：通过继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。在抽象方法的实现过程中，使用同步器提供的(getState(),setState(int newState), compareAndSetState(int expect, int update))来进行操作，这三个状态管理方法能保证状态的改变是安全的。支持独占式和共享式地获取同步状态。



锁与同步器的关系：

- 锁是面向使用者的，定义使用者与锁交互的接口(如可以允许两个线程并行访问)，并隐藏了实现细节;
- 同步器是锁的实现者的，简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。

同步器提供的模板方法：

- 独占式获取与释放同步状态
- 共享式获取与释放同步状态
- 查询同步队列中的等待线程情况



独占锁： 在某一时刻，只能有一个线程获取到锁，而其他获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能获取锁。

#### 队列同步器的实现分析

- 同步队列
  - 使用一个内部同步队列(FIFO双向同步队列)完成同步状态的管理，当前线程获取同步状态失败时,同步器会将当前线程及等待信息构成一个节点(Node)并将其加入同步队列，同时阻塞当前线程，当同步状态释放时，同步器将队列中首节点对应的线程唤醒，使其再次尝试获取同步状态。
  - Node节点保存获取同步状态失败的线程引用、等待状态以及前驱结点和后继节点。
  - 由于可能会有多个线程同时尝试获取同步状态，而只有一个线程能获取同步状态，其余的线程会被构造成节点加入到同步队列中，所以**入队的过程需要保证线程安全**
  - 同步队列中的首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，会唤醒后继节点，而后继节点会在获取同步状态时将自己设置成首节点。而只有一个线程能成功获取到同步状态，所以设置首节点的方法本身就是线程安全的，不需要使用CAS来保证
- 独占式同步状态获取与释放
- 共享式同步状态获取与释放
- 超时获取同步状态
- 模板方法




补充知识：

公平锁：最先进入同步队列的线程先获得锁

非公平锁：锁释放之后，会唤醒所有的线程，让他们再次尝试获取锁，可能会导致后来的线程鲜活的锁







注：volatile修饰的变量在多线程中的单操作中可以保证写后读的可见性，但是并不能保证线程安全。例如在以来原始值时，线程是不安全的。

在AbstractQueuedSychronizer中compareAndSetState(int expect, int update)方法可以划分为一下操作：

1. 比较expect和state变量的当前值，如果相同，继续2，如果不同，返回false，方法结束
2. 将state当前值设为update，并发回true，方法结束

这两个操作，如果是多线程并发调用，是会有线程安全问题的。这里的 cas 方法利用了 cpu 的 cas 指令，这个指令是原子操作。可以避免并发问题。